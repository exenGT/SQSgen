import osimport numpy as npfrom scipy.sparse import csr_matrixfrom FindAdjacencyMatrix import *from utils import *import random################## function definitions ##################def findSQS(A, S, D):    ### A should be a sparse matrix    SQS = np.dot(np.transpose(S), A.dot(S)) / (2 * len(S) * D)    return np.abs(SQS)def optimize_SQS(A_J2, A_K2, A_L2, A_M2, D_J2, D_K2, D_L2, D_M2):    A_J2_csr = csr_matrix(A_J2)    A_K2_csr = csr_matrix(A_K2)    A_L2_csr = csr_matrix(A_L2)    A_M2_csr = csr_matrix(A_M2)    ### initialize spin vector S    S_half = np.ones(len(A_J2) / 2)    S = np.concatenate((S_half, np.negative(S_half)))    np.random.shuffle(S)    ### initialization for optimization    Tmax = 100    Tmin = 0.01    #Tstep = 0.01    T = Tmax    numStep = 0    tol = 0.0    #SQS = findSQS(A_J2_csr, S, D_J2) + findSQS(A_K2_csr, S, D_K2) + findSQS(A_L2_csr, S, D_L2) \    #      + findSQS(A_M2_csr, S, D_M2)    SQS = findSQS(A_J2_csr, S, D_J2)    prevSQS = SQS    S_opt = []    max_len = 5    ### optimization loop    while T > Tmin:        if len(S_opt) == max_len:            break        ### swap two random spin variables in S with opposite signs        S_p = np.where(S == 1.)[0]        S_n = np.where(S == -1.)[0]        a = np.random.choice(S_p)        b = np.random.choice(S_n)        S[b], S[a] = S[a], S[b]        # SQS = findSQS(A_J2_csr, S, D_J2) + findSQS(A_K2_csr, S, D_K2) + findSQS(A_L2_csr, S, D_L2) \        #      + findSQS(A_M2_csr, S, D_M2)        SQS = findSQS(A_J2_csr, S, D_J2)        dSQS = SQS - prevSQS        if dSQS <= 0:            prevSQS = SQS            if SQS <= tol:                if any([np.array_equal(S, S_stored) for S_stored in S_opt]):                    print(numStep)                else:                    print(numStep)                    print(SQS)                    S_opt.append(S)                S = np.random.permutation(S)        else:            r = np.random.rand()            prob = 1/(1 + np.exp(dSQS/T))            if r <= prob:                prevSQS = SQS            else:                S[b], S[a] = S[a], S[b]        numStep += 1        decay = 1./(len(S))        T *= np.exp(-decay)        #T -= Tstep    print(numStep)    return S_opt######################################################################def createRandomS(numAtoms):	S = []	for i in range(numAtoms):		S.append(1)	while len([a for a in S if a == -1]) < len(S)/2:		rn = random.randint(1,numAtoms)		S[rn-1] = -1	return Sdef switchAtoms(S):	plusOnes, minusOnes = [],[]	for i in range(len(S)):		if S[i] == 1:			plusOnes.append(i)		else:			minusOnes.append(i)	rn1 = random.randint(0,len(plusOnes))	rn2 = random.randint(0,len(minusOnes))	S[rn1] = -1	S[rn2] = 1	return Sdef MC_SQS(A_J2, A_K2, A_L2, A_M2, D_J2, D_K2, D_L2, D_M2):    A_J2_csr = csr_matrix(A_J2)    A_K2_csr = csr_matrix(A_K2)    A_L2_csr = csr_matrix(A_L2)    A_M2_csr = csr_matrix(A_M2)    ### initialize spin vector S    S = createRandomS(len(A_J2))    ### initialize optimization loop    numberOfTrials = 100    numberOfS = 5    threshold = 0.01    saved_S = []    ### optimization loop    while len(saved_S) < numberOfS:        old_sqs = 1000        S = createRandomS(len(A_J2))        n = 0        while n < numberOfTrials:            ### swap two random spin variables in S with opposite signs            new_S = switchAtoms(S)  # Here, we randomly swith a +1 and a -1            ### calculate new SQS            new_sqs = findSQS(A_J2_csr, S, D_J2) + findSQS(A_K2_csr, S, D_K2) + findSQS(A_L2_csr, S, D_L2) \                  + findSQS(A_M2_csr, S, D_M2)            #new_sqs = findSQS(A_J2_csr, S, D_J2)            if new_sqs < old_sqs:                accept = True            else:                rn = np.random.rand()                if rn > 0.5:                    accept = True            if accept:                S = new_S            old_sqs = new_sqs            # Everytime we find a good S, we keep it and start over by reinitializing old_sqs to a large number            if new_sqs <= threshold:                if S not in saved_S:                    saved_S.append(S)                    print(S)                    print(new_sqs)                break            n += 1    return saved_S################## call the functions ##################os.chdir("C:\\Users\\pc\\Desktop\\vnl")    # change to your own directoryinfname, cell_params, cell_angles, frac_coords = readcif()print("Cell parameters are ", cell_params)print("Cell angles are ", cell_angles)cell_angles_rad = np.radians(cell_angles)A_J2 = findA(J2, cell_params, cell_angles_rad, frac_coords)A_K2 = findA(K2, cell_params, cell_angles_rad, frac_coords)A_L2 = findA(L2, cell_params, cell_angles_rad, frac_coords)A_M2 = findA(M2, cell_params, cell_angles_rad, frac_coords)#A_N2 = findA(N2, cell_params, cell_angles_rad, frac_coords)#A_O2 = findA(O2, cell_params, cell_angles_rad, frac_coords)S_opt = optimize_SQS(A_J2, A_K2, A_L2, A_M2, D_J2, D_K2, D_L2, D_M2)#S_opt = MC_SQS(A_J2, A_K2, A_L2, A_M2, D_J2, D_K2, D_L2, D_M2)print(S_opt)for num in range(len(S_opt)):    writecif(infname, num, S_opt[num])